# EASY REAL RULES - ざっくりガイド

REALRULES.md の内容を「初めてでもイメージできる」ように噛み砕いた説明です。組織グラフがどんな形でも同じ手順で負荷を測れるようにするための流れを、3ステップで押さえます。

---

## 1. 入力するデータ（何を用意する？）

1. **組織グラフ**  
   - ノード（Nodes.csv / node_link.nodes など）  
     | フィールド | 必須 | 例 | 説明 |
     |-----------|------|----|------|
     | `node_id` | ✔ | 42 | グラフ内のユニークID |
     | `label` | ✔ | "Mgr_A" | 表示用ラベル |
     | `role` | ✔ | "Manager" | 役職。遷移ルールに利用 |
     | `level` | ✔ | 2 | 階層番号（0=上層） |
     | `org_unit` | ✔ | "ProductA" | 部門／サブツリー識別 |
     | 任意: `capacity`, `team_size`, `region` など属性を追加してもOK |
   - エッジ（Edges.csv / node_link.links / 隣接行列）  
     | フィールド | 必須 | 例 | 説明 |
     |-----------|------|----|------|
     | `source` | ✔ | 10 | 依頼元ノードID |
     | `target` | ✔ | 42 | 依頼先ノードID |
     | `weight` | ✔ | 0.3 | タスクがこの経路を通る頻度・確率・調整コストなど |
     | 任意: `type`（例: approval, dev）、`max_capacity` など |
   - フォーマットは JSON（node_link）、CSV（edge list）、隣接行列（行列+属性テーブル）から選べる。NetworkX に読み込めればOK。

2. **タスク設定（tasks.yaml）**  
   - 主なキーと意味  
     | キー | 例 | 説明 |
     |------|----|------|
     | `task_categories[].name` | "feature_dev" | タスク種別名 |
     | `complexity` | 4 | 技術的難度（1-5） |
     | `stakeholders` | 3 | 関係者数（人数やグループ数） |
     | `comms_cost` | 2 | 調整コスト（1-5） |
     | `allowed_roles` | ["Director", "Manager", "TeamLead"] | このタスクを扱える役職 |
     | `escalation_threshold` | 12 | これを超えるとエスカレーション |
     | 任意: `spawn_rate`, `deadline`, `priority` など |
   - 全体設定  
     | キー | 例 | 説明 |
     |------|----|------|
     | `escalation_probability` | 0.05 | 基本のエスカレーション確率 |
     | `default_weight_formula` | `0.4*c + 0.4*s + 0.2*p` | 重み算出式（記号は complexity/stakeholders/comms_cost を表す） |

3. **シナリオ設定（scenario.yaml）**  
   - 複数の入力ファイルとシミュレーション条件を束ねる  
     | キー | 例 | 説明 |
     |------|----|------|
     | `graph_source` | `data/org_chart_node_link.json` | 組織グラフのパス |
     | `adjacency_matrix` | `data/org_adj_matrix.csv` | 任意。隣接行列を直接使う場合 |
     | `task_config` | `configs/tasks.yaml` | タスク設定ファイル |
     | `simulation_steps` | 100 | シミュレーションのステップ数 |
     | `num_tasks` | 500 | 生成するタスク数 |
     | `forest_subgraphs` | `[{"name": "ProductA", "node_ids": [0,1,...]}]` | 部門ごとのノード集合 |
     | `cross_links` | `[{"from": "ProductA.Manager", "to": "ProductB.Manager", "weight": 0.1}]` | 部門間エッジ |
     | 任意: `seed`, `movement_rule`, `report_output` など |

---

## 2. タスクの動き方（ルールは？）

- **通常フロー**: 上層 → 中間層 → 実行層でタスクを渡し、完了したら実行層が終了報告。下から上へ直接戻る道は基本なし。
- **報告ルート**: 実行層から中間層へ報告し、中間層が必要なら上層に伝える。
- **エスカレーション**: 難しすぎる、調整相手が多すぎるなどで重さが閾値を超えたタスクは、例外的に上層に戻して再判断する。確率は低く設定（例: 5%）。
- **役割別の制限**: 役職ごとに遷移できる相手が決まっている（CEOは直接シニアに渡さない、ジュニアはCEOに直接話に行かない、など）。
- **負荷の測り方**: 「訪問回数」ではなく、タスクの重さ（難しさ＋関係者＋調整コスト）を合計し、その総量で各ノードの負担を見る。

---

## 3. シミュレーションでやること（どう分析する？）

1. **グラフとタスク設定を読み込む**（どんな形でもOK）。
2. **タスクをAgentとして生成**し、REAL RULES のフローに従って移動。各ノードの負荷を `node_load` に重みとして足していく。
3. **中心性指標を計算**して、どのノードが構造上重要かを把握。
4. **負荷と中心性を組み合わせて比較**  
   - 階層別の「平均負荷」「最大負荷」  
   - 中心性が高いのに負荷が少ない or その逆 などを観察し、中間層の負担が軽くなる構造を探る。
5. **シナリオ比較**: `scenario.yaml` を変えるだけで、組織の大きさや部門数、クロスリンクの有無を比較できる。

---

## よくある質問（FAQ）

- **Q1. 木構造じゃないグラフでも動く？**  
  A. はい。node_link や隣接行列を読み込めればどんな有向グラフでも同じルールで処理します。

- **Q2. 役職情報がないとだめ？**  
  A. はい。REAL RULES の遷移ルールは役職に依存するため、最低でも `role` と `level` を設定してください。

- **Q3. エスカレーションの確率は固定？**  
  A. `tasks.yaml` でカテゴリごとに変えたり、全体パラメータで調整できます。

- **Q4. 負荷はどう集計する？**  
  A. `node_load[node_id] += task.weight` のようにタスクの重さを足し、最後に各階層で集約・比較します。

---

この EASY REAL RULES を読めば、REALRULES.md の全体像を掴んだうえで具体的な設定ファイルやシミュレーション手順に進めます。
